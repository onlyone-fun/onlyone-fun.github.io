---
icon: pen-to-square
date: 2024-07-04
category:
  - Java
tag:
  - Java
---


# JVM

## JVM概述（Write Once，Run Anywhere）

> JVM全称 `Java Virtual Machine`,中文译名为Java虚拟机。JVM 本质上是一个运行在计算机上的程序，他的职责是运行Java字节码文件。
>
> **Java代码执行流程：**
>
> Java源文件 --> Java编译器（javac命令）将源代码编译成java字节码文件 --> 虚拟机运行并加载字节码文件并启动一个新的进程

### 功能

1. 解释&运行

   将字节码文件中的字节码指令实时地解释成机器码

2. 内存管理

   自动为对象、方法等分配内存

   自动的垃圾回收机制，回收不再使用的对象

3. 即时编译

   对热点代码进行优化，提升执行效率，即时编译是提升Java程序性能最核心的手段



### 常见JVM

- 最常见的是`HotSpot`

| 名称                       | 作者    | 支持版本                  | 社区活跃度（github star） | 特性                                                         | 适用场景                             |
| -------------------------- | ------- | ------------------------- | ------------------------- | ------------------------------------------------------------ | ------------------------------------ |
| HotSpot (Oracle JDK版)     | Oracle  | 所有版本                  | 高(闭源)                  | 使用最广泛，稳定可靠，社区活跃JIT支持Oracle JDK默认虚拟机    | 默认                                 |
| HotSpot (Open JDK版)       | Oracle  | 所有版本                  | 中(16.1k)                 | 同上开源，Open JDK默认虚拟机                                 | 默认对JDK有二次开发需求              |
| GraalVM                    | Oracle  | 11, 17,19企业版支持8      | 高（18.7k）               | 多语言支持高性能、JIT、AOT支持                               | 微服务、云原生架构需要多语言混合编程 |
| Dragonwell JDK龙井         | Alibaba | 标准版 8,11,17扩展版11,17 | 低(3.9k)                  | 基于OpenJDK的增强高性能、bug修复、安全性提升JWarmup、ElasticHeap、Wisp特性支持 | 电商、物流、金融领域对性能要求比较高 |
| Eclipse OpenJ9 (原 IBM J9) | IBM     | 8,11,17,19,20             | 低(3.1k)                  | 高性能、可扩展JIT、AOT特性支持                               | 微服务、云原生架构                   |

## 字节码文件详解

### 虚拟机组成

![虚拟机组成](/assets/images/JAVA/JVM/虚拟机组成.png)

- 类加载子系统：核心组件类加载器，负责将字节码文件中的内容加载到内存中
- 运行时数据区：JVM管理的内存，创建出来的对象、类的信息等等内容都会放在该区域
- 执行引擎：包含了及时编译器、解释器、垃圾回收器，执行引擎使用解释器将字节码指令解释成机器码，使用及时编译器优化性能，使用垃圾回收器回收不再使用的对象
- 本地接口：调用本地使用C/C++编译好的方法，本地方法在java中声明时，都会带上`native`关键字



### 字节码文件组成

> 字节码文件为 二进制存储。可以使用 NotePad++使用 十六进制插件查看class文件
>
> 可以使用`jclasslib`工具查看字节码文件

- 基础信息：魔术、字节码文件对应的Java版本号、访问标识（public final等等）、父类和接口信息
- 常量池：保存了字符串常量、类或接口名、字段名，主要在字节码指令中使用
- 字段：当前类或接口声明的字段信息
- 方法：当前类或接口声明的方法信息，核心内容为方法的字节码指令
- 属性：类的属性，例如源码的文件名、内部类的列表等等



#### 基本信息

基本信息包含了 `jclasslib` 中能看到的两块内容

- Magic魔术

  > 每个Java字节码文件的前四个字节时固定的，用十六进制表示 -->`0xcafebabe`。因为文件是无法通过文件扩展名来确定文件类型的，文件扩展名可以随意修改而不影响文件的内容。软件会使用文件的头几个字节（文件头）校验文件的类型，如果软件不支持该类型就会出错

- 主副版本号

  > 主副版本号指的是编译字节码文件时使用的JDK版本号，主版本号用来标识大版本号，JDK1.0-1.1使用了45.0-45.3，JDK1.2是46之后每升级一个大版本就加一，副版本号是当主版本号相同时作为区分不同版本的标识
  >
  > **1.2之后大版本计算方式**： 主版本号 - 44     （52.0为JDK1.8）
  >
  > ps：
  >
  > 当使用较低版本的JDK去运行较高版本JDK的字节码文件，无法使用会显示如下错误（一般建议降低依赖版本或更换依赖）：
  >
  > ![JDK版本不兼容报错](/assets/images/JAVA/JVM/JDK版本不兼容报错.png)

- 其他基础信息

  > 包括访问标识（public、final、private、protected）、类（父类、本类）、接口索引



#### 常量池

字节码文件中常量池的作用：避免相同的内容重复定义，节省空间。



> 常量池中的数据都有一个编号，编号从1开始。在字段或者字节码指令中通过编号快速找到这个字符串。
>
> 字节码指令中通过编号引用到常量池的过程称之为**符号引用**



#### 字段

字段中存放的是当前类或接口声明的字段信息。包含字段的名字、描述符（字段类型）、访问标识（publi\private、final等）。

#### 方法

字节码中的方法区是存放**字节码指令**的核心位置，字节码指令的内容存放在方法的Code属性中

#### 属性

属性主要是指类属性，比如源码的文件名、内部类的列表等。



### 字节码工具

1. javaP 

   JDK中自带的反编译工具，可以通过控制台查看字节码文件的内容，适合在服务器上查看字节码文件内容

   ``` sh
   javap -v 字节码文件名称 # 如果为jar包，需要先使用 jar -xvf 命令解压
   ```

2. jclasslib

   - jclasslib --> IDEA插件   选择` view - Show Bytecode With Jclasslib`

   - 软件

3. Arthas

   文档网址：https://arthas.aliyun.com/doc/quick-start.html

   > 常用命令
   >
   > - dump：可以将字节码文件保存到本地 `dump -d 输出目录 类的全限定名`
   >
   > - jad：将类的字节码文件进行反编译成源代码，用于确认服务器上字节码文件是否最新 `jad --source-only 类的全限定名`
   >
   > - classloader：查看类加载器的继承树
   > - sc -d 类名 查看加载该类的详细信息
   > - classloader -l 查看类加载器的详细信息
   > - classloader -c 类加载器hash值 查看类加载器的详细路径
   >
   > 



### 类的生命周期

类的生命周期描述了一个类加载、使用、卸载的整个过程

- 加载 --> 连接（验证 、准备、解析）--> 初始化 --> 使用 --> 卸载

#### 加载阶段

1. 类加载器根据类的全限定名通过不同的渠道以二进制的方式获取字节码信息，可以使用Java代码拓展不同的渠道

   - 本地磁盘上获取文件

   - 运行时通过动态代理生成，比如Spring框架

   - Apple技术通过网络获取字节码文件

2. 类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到方法区中，方法区中生成一个`InstanceKlass`对象，保存类的所有信息，其中还包含实现特定功能比如多态的信息
3. 虚拟机同时会在堆上生成与方法区中数据类似的`java.lang.Class`对象，作用是java代码中去获取类的信息以及存储静态字段的数据（JDK8之后）

#### 连接阶段

- 验证，验证内容是否满足《Java虚拟机规范》
- 准备，给静态变量赋初值
- 解析，将常量池中的符号引用替换成指向内存的直接引用

1. 验证

   验证的主要目的是检测Java字节码文件是否遵守了《Java虚拟机规范》中的约束。这个阶段一般不需要程序员参与。主要包含如下四部分，具体详见《Java虚拟机规范》：

   > - 文件格式验证：必须以 `0xcafebabe`开头，主次版本号是否满足当前Java虚拟机版本要求
   > - 元信息验证，例如类必须有父类（super不能为空）
   > - 验证程序执行指令的语义，比如方法内的指令执行中跳转到不正确的位置
   > - 符号引用验证，例如是否访问了其他类中private的方法等

:zap:编译文件的主版本号不能高于运行环境主版本号，若主版本号相等，副版本号也不能超过。

JDK8中：

``` java
return (major >= JAVA_MIN_SUPPORTED_VERSION) &&
    (major <= mac_version) &&
    ((major != max_version )||
     (minor <= JAVA_MAX_SUPPORTED_MINOR_VERSION)))
```

2. 准备

   准备阶段为静态变量（static）、分配内存并设置初值，每一种基本数据类型和引用数据类型都有其初值

   | **数据类型**     | **初始值**   |
   | ---------------- | ------------ |
   | **int**          | **0**        |
   | **long**         | **0L**       |
   | **short**        | **0**        |
   | **char**         | **‘\u0000’** |
   | **byte**         | **0**        |
   | **boolean**      | **false**    |
   | **double**       | **0.0**      |
   | **引用数据类型** | **null**     |

   > final 修饰的基本数据类型静态变量，准备阶段直接会将代码中的值进行赋值

3. 解析

   解析阶段主要将常量池中的符号引用替换为**直接引用**，符号引用就是在字节码文件中使用编号来访问常量池中的内容，直接引用不使用编号，而是使用内存中地址进行访问具体数据



#### 初始化

初始化阶段会执行字节码文件中 `clinit(class init 类的初始化)`方法的字节码指令，包含静态代码块中的代码，并为静态变量赋值



:zap:类初始化触发时机

1. 访问一个类的静态变量或者静态方法，若变量是final修饰的并且等号右侧是常量不会触发初始化
2. 调用 `Class.forName(String className)`
3. new 一个该类的对象时
4. 执行Main方法的当前类

> 添加 -XX:+TraceClassLoading 参数可以打印出加载并初始化类

:zap:静态代码块和代码块

1. 静态代码块会在类加载时机触发，且执行一次
2. 代码块是在创建对象时执行，且在构造方法执行之前执行
3. 静态代码块和静态变量，会按照他们的生声明顺序进行执行

:zap:`clinit函数`不会执行的情况

1. 无静态代码块且无静态变量赋值语句
2. 有静态变量声明，但没有赋值语句
3. 静态变量的定义使用final关键字，这类变量会在准备阶段直接进行初始化



> - 在继承中，通过子类访问父类静态变量，不会触发子类的初始化
> - 对象数组的创建不会导致数组中元素的初始化
> - final修饰的变量若赋值的内容需要执行指令才能得出结果，会执行clinit方法进行初始化



### 类加载器

​	类加载器（ClassLoader）是Java虚拟机提供给应用程序去实现获取类和接口字节码数据的技术，类加载器只参与加载过程中的字节码获取并加载到内存这一部分

![类加载器流程](/assets/images/JAVA/JVM/类加载器流程.png)

类加载器会通过二进制流的方式获取到字节码文件的内容，并将数据交给Java虚拟机，虚拟机会在方法区和堆区上生成对应的对象保存字节码信息

#### 分类

- 虚拟机底层实现：源代码位于Java虚拟机的源码中，实现语言与虚拟机底层语言一致，比如Hotstop使用C++，主要目的是保证Java程序运行中基础类被正确加载，确保其可靠性
- JDK默认提供或自定义：JDK默认提供了多种处理不同渠道的类加载器，也可以自己根据需求定制，使用Java语言，所有Java中实现的类加载器都需要继承ClassLoader这个抽象类

:zap:JDK8之前的类加载器：

![JDK8之前类加载器](/assets/images/JAVA/JVM/JDK8之前类加载器.png)

> - `BootStrapClassLoader`是启动类加载器，Arthas中`numberIfstance`为类加载器的数量，`loadedCountTotal`为加载类的数量
> - `ExtClassLoader`是扩展类加载器
> - `AppClassLoader`是应用程序类加载器



#### 启动类加载器

- `BootStrap ClassLoader`是由Hotspot虚拟机提供的、使用C++编写的类加载器
- 默认加载Java安装目录`/jre/lib`下的类文件，比如`rt.jar`、`tools.jar`、`resources.jar`等

``` java
/**
 * 启动程序类加载器案例
 */
public class BootstrapClassLoaderDemo {
    public static void main(String[] args) throws IOException {
        ClassLoader classLoader = String.class.getClassLoader();
        System.out.println(classLoader);
        System.in.read();
    }
}
```

> 加载String类的类加载器，打印结果为 null ,因为启动类加载器是 JDK8中由C++语言来编写的，在Java代码中去获取既不适合也不安全，从而使用null

**扩展基础jar包**

当想扩展一些比较基础的jar包，让启动类加载器加载的方式：

- 放入`jre/lib`下进行扩展，:zap:尽可能的不要去修改JDK安装目录中的内容，会出现放进去由于文件名不匹配的问题，从而不能被正常加载   ---- 不推荐
- 使用参数进行扩展，使用`-Xbootclasspath/a:jar包目录/jar包名`进行扩展，参数中 /a 代表新增



#### 扩展类加载器&&应用程序类加载器

- 扩展类加载器和应用程序类加载器都是JDK提供、使用Java编写的类加载器
- 源码位于 `sun.misc.Launcher`中，是一个静态内部类，继承自URLClassLoader，具备通过目录或指定jar包将字节码文件加载到内存中

![类加载器继承关系](/assets/images/JAVA/JVM/类加载器继承关系.png)

- ClassLoader类定义了具体的行为模式，简单来说就是先从本地或者网络获得字节码信息，然后调用虚拟机底层的方法创建方法区和堆上的对象。这样的好处就是让子类只需要去实现如何获取字节码信息这部分代码。
- SecureClassLoader提供了证书机制，提升了安全性。
- URLClassLoader提供了根据URL获取目录下或者指定jar包进行加载，获取字节码的数据。
- 扩展类加载器和应用程序类加载器继承自`URLClassLoader`，获得了上述的三种能力。



1. 扩展类加载器

   扩展类加载器默认加载安装目录中`/jre/lib/ext`下的类文件

   > ScriptEnvironment是nashorn框架中用来运行javascript语言代码的环境类，他位于nashorn.jar包中被扩展类加载器加载
   >
   > ``` java
   > /**
   >  * 扩展类加载器
   >  */
   > public class ExtClassLoaderDemo {
   >     public static void main(String[] args) throws IOException {
   >         ClassLoader classLoader = ScriptEnvironment.class.getClassLoader();
   >         System.out.println(classLoader);
   >     }
   > }
   > ```
   >
   > 

通过扩展类加载器去加载额外jar包：

- 放入`/jre/lib/ext`下进行扩展。:zap:尽可能不要去更改JDK安装目录中的内容
- 使用参数进行扩展使用参数进行扩展。:zap:使用`-Djava.ext.dirs=jar`包目录 进行扩展,这种方式会覆盖掉原始目录，可以用`;(windows):(macos/linux)`追加上原始目录

> 当目录中出现空格，需要将路径用引号包裹起来

2. 应用程序类加载器

   应用程序类加载器会加载`classpath`下的类文件，默认加载的是项目中类以及通过maven引入的第三方jar包中的类







